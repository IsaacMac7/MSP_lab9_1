"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetaSection = void 0;
var regression = require("regression");
var defaultConfig = {
    type: 'linear',
    calculation: {
        precision: 2,
        order: 2
    },
    line: {
        width: 2,
        color: '#000',
        dash: []
    },
    extendPredictions: false,
    copy: {
        overwriteData: 'none'
    }
};
var MetaSection = /** @class */ (function () {
    function MetaSection(sec, _meta) {
        this._meta = _meta;
        var chart = _meta.chart;
        var ds = _meta.dataset;
        var cfg = getConfig([
            'type',
            'calculation',
            'line',
            'extendPredictions',
            'copy'
        ]);
        this.startIndex = sec.startIndex || 0;
        this.endIndex = sec.endIndex || ds.data.length - 1;
        this.type = Array.isArray(cfg.type) ? cfg.type : [cfg.type];
        this.line = cfg.line;
        this.calculation = cfg.calculation;
        this.extendPredictions = cfg.extendPredictions;
        this.copy = cfg.copy;
        this.label =
            sec.label || this._meta.chart.data.labels[this.endIndex];
        this._validateType();
        // --- constructor helpers
        /**
         * Calculate the inherited configuration from defaultConfig, globalConfig,
         * dataset config, and section config (in that order)
         */
        function getConfig(fields) {
            var o, p;
            var globalConfig = ((o = chart.config.options) && (p = o.plugins) && p.regressions) || {};
            return configMerge(fields, defaultConfig, globalConfig, ds.regressions, sec);
            /** merge the config objects */
            function configMerge(fields) {
                var cfgList = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    cfgList[_i - 1] = arguments[_i];
                }
                var dstConfig = {};
                fields.forEach(function (f) {
                    cfgList.forEach(function (srcConfig) {
                        var o = srcConfig[f];
                        var t = typeof o;
                        if (t != 'undefined') {
                            if (Array.isArray(o) || t != 'object' || o == null)
                                dstConfig[f] = o;
                            else
                                dstConfig[f] = Object.assign({}, dstConfig[f], configMerge(Object.keys(o), o));
                        }
                    });
                });
                return dstConfig;
            }
        }
    }
    /** Validates the type to avoid inconsistences */
    MetaSection.prototype._validateType = function () {
        if (this.type.length > 1 && this.type.includes('copy'))
            throw Error('Invalid regression type:' +
                this.type +
                '. "none" cannot be combined with other type!');
    };
    /** Calculates the regression(s) and sets the result objects */
    MetaSection.prototype.calculate = function () {
        var sectionData = this._meta.normalizedData.slice(this.startIndex, this.endIndex + 1);
        if (this.type[0] == 'copy')
            this._calculateCopySection(sectionData);
        else
            this._calculateBestR2(sectionData);
    };
    MetaSection.prototype._calculateBestR2 = function (sectionData) {
        var _this = this;
        this.result = this.type.reduce(function (max, type) {
            var calculation = Object.assign({}, _this.calculation);
            var realType = type;
            if (/polynomial[34]$/.test(type)) {
                calculation.order = parseInt(type.substr(10));
                realType = type.substr(0, 10);
            }
            var r = regression[realType](sectionData, calculation);
            r.type = type;
            return !max || max.r2 < r.r2 ? r : max;
        }, null);
    };
    MetaSection.prototype._calculateCopySection = function (sectionData) {
        var _this = this;
        var from = this._meta.sections[this.copy.fromSectionIndex], r = (this.result = Object.assign({}, from.result)), overwrite = this.copy.overwriteData, data = this._meta.normalizedData;
        r.points = sectionData.map(function (p) { return r.predict(p[0]); });
        delete r.r2;
        if (overwrite != 'none') {
            var dsdata_1 = this._meta.dataset.data, isXY_1 = this._meta.isXY;
            r.points.forEach(function (_a, i) {
                var x = _a[0], y = _a[1];
                var index = i + _this.startIndex;
                if ((index < from.startIndex || index > from.endIndex) &&
                    (overwrite == 'all' ||
                        (overwrite == 'last' && index == _this.endIndex) ||
                        (overwrite == 'empty' && !data[index]))) {
                    if (_this.copy.maxValue)
                        y = Math.min(_this.copy.maxValue, y);
                    if (_this.copy.minValue !== undefined)
                        y = Math.max(_this.copy.minValue, y);
                    dsdata_1[index] = isXY_1 ? { x: x, y: y } : y;
                }
            });
        }
    };
    MetaSection.prototype.drawRightBorder = function (ctx) {
        ctx.beginPath();
        this._setLineAttrs(ctx);
        ctx.setLineDash([10, 2]);
        ctx.lineWidth = 2;
        // Print vertical line
        var p = this._meta.getXY(this.endIndex, 0);
        ctx.moveTo(p.x, this._meta.topY);
        ctx.lineTo(p.x, this._meta.bottomY);
        ctx.fillStyle = this.line.color;
        ctx.fillText(this.label, p.x, this._meta.topY);
        ctx.stroke();
    };
    MetaSection.prototype.drawRegressions = function (ctx) {
        for (var i = 0, len = this._meta.sections.length; i < len; i++) {
            var section = this._meta.sections[i];
            var isMe = section == this;
            if ((isMe && this.type[0] != 'copy') ||
                (!isMe && this.extendPredictions)) {
                section.drawRange(ctx, this.startIndex, this.endIndex, !isMe);
            }
            if (isMe)
                break;
        }
    };
    MetaSection.prototype.drawRange = function (ctx, startIndex, endIndex, forceDash) {
        var _this = this;
        ctx.beginPath();
        this._setLineAttrs(ctx);
        if (forceDash)
            ctx.setLineDash([5, 5]);
        var predict = this.result.predict;
        var f = function (x) { return _this._meta.getXY(x, predict(x)[1]); };
        var p = f(startIndex);
        ctx.moveTo(p.x, p.y);
        for (var x = startIndex + 1; x <= endIndex; x++) {
            p = f(x);
            ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
    };
    MetaSection.prototype._setLineAttrs = function (ctx) {
        if (this.line.width)
            ctx.lineWidth = this.line.width;
        if (this.line.color)
            ctx.strokeStyle = this.line.color;
        if (this.line.dash)
            ctx.setLineDash(this.line.dash);
    };
    return MetaSection;
}());
exports.MetaSection = MetaSection;
//# sourceMappingURL=MetaSection.js.map